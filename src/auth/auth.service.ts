import {
  BadRequestException,
  Inject,
  Injectable,
  UnauthorizedException,
  InternalServerErrorException,
  NotFoundException,
  ConflictException,
} from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { SignUpDto } from './dto/signupdto';
import { LoginData } from './schema/login.schema';
import { User } from './schema/user.schema';
import * as bcrypt from 'bcrypt';
import { JwtService } from '@nestjs/jwt';
import { error } from 'console';
import { ConfigService } from '@nestjs/config';
import { BookMark } from 'src/posts/schema/bookmark.schema';
import { Follow } from 'src/follow/entities/follow.entity';
import * as nodemailer from 'nodemailer';
import { OnModuleInit } from '@nestjs/common';
import { Otp } from './schema/otp.schema';
import { formatDateTime } from 'src/utils/date-time.util';

@Injectable()
export class AuthService implements OnModuleInit {
  constructor(
    @InjectModel(User.name) private userModel: Model<User>,
    private jwtService: JwtService,
    private configService: ConfigService,
    @InjectModel(BookMark.name) private BookMarkModel: Model<BookMark>,
    @InjectModel(Follow.name) private FollowModel: Model<Follow>,
    @InjectModel(Otp.name) private otpModel: Model<Otp>,
  ) {}
  async onModuleInit() {
    await this.userModel.syncIndexes();
  }
  async registerUser(signUpData: SignUpDto) {
    try {
      const { name, phone, email, password } = signUpData;
      let user = await this.userModel.findOne({ email });
      if (user) {
        throw new UnauthorizedException('Email ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng');
      }
      console.log(phone);

      if (phone != null) {
        let validPhone = await this.userModel.findOne({ phone });
        if (validPhone) {
          throw new UnauthorizedException('S·ªë ƒëi·ªán tho·∫°i ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng');
        }
      }
      const hashedPassword = await bcrypt.hash(password, 10);

      const registedUser = await this.userModel.create({
        email,
        password: hashedPassword,
        name,
        phone,
      });
      const savedUser = await registedUser.save();

      // Kh·ªüi t·∫°o bookmark cho ng∆∞·ªùi d√πng m·ªõi
      await this.initializeBookMark(savedUser._id.toString());

      await this.initializeFollow(savedUser._id.toString());

      return {
        message: 'T·∫°o t√†i kho·∫£n th√†nh c√¥ng',
      };
    } catch (error) {
      if (error.code === 11000) {
        // L·∫•y tr∆∞·ªùng b·ªã tr√πng
        const field = Object.keys(error.keyValue)[0];
        // L·∫•y gi√° tr·ªã b·ªã tr√πng
        const value = error.keyValue[field];
        throw new ConflictException(
          `Gi√° tr·ªã '${value}' c·ªßa tr∆∞·ªùng '${field}' ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng`,
        );
      }
      if ((error.code = 401)) {
        throw new UnauthorizedException('T√†i kho·∫£n ƒë√£ ƒëƒÉng k√≠');
      }
      throw new InternalServerErrorException(
        'ƒê√£ x·∫£y ra l·ªói khi ƒëƒÉng k√Ω t√†i kho·∫£n ' + error,
      );
    }
  }

  async loginAsPhone(loginData: LoginData) {
    try {
      const { phone, password, fcmToken } = loginData;
      let user = await this.userModel.findOne({ phone });
      if (!user) {
        throw new UnauthorizedException(
          'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng: ' + phone + ' ' + password,
        );
      }

      const passwordMatches = await bcrypt.compare(password, user.password);
      if (!passwordMatches) {
        throw new UnauthorizedException('M·∫≠t kh·∫©u kh√¥ng ch√≠nh x√°c');
      }
      if (user.isBanned) {
        return {
          accessToken: null,
          message: `T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ b·ªã kh√≥a ƒë·∫øn ng√†y ${formatDateTime(user.bannedUntil)}`,
        };
      }
      if (fcmToken) {
        this.addFCMToken(user, fcmToken);
      }
      const tokens = await this.generateUserTokens(
        user._id,
        user.email,
        user.name,
        user.phone,
        user.role,
      );

      const cacheKey = `user_${user._id}`;
      return {
        accessToken: tokens.accessToken,
        message: 'ƒêƒÉng nh·∫≠p th√†nh c√¥ng',
      };
    } catch {
      if (error instanceof UnauthorizedException) {
        throw error;
      }
      throw new InternalServerErrorException('ƒê√£ x·∫£y ra l·ªói khi ƒëƒÉng nh·∫≠p');
    }
  }

  async loginAsEmail(loginData: LoginData) {
    try {
      console.log('Dang nhap bang email');

      const { email, password, fcmToken } = loginData;
      let user = await this.userModel.findOne({ email });
      console.log('Da tim theo email');

      if (!user) {
        throw new UnauthorizedException(
          'Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng: ' + email + ' ' + password,
        );
      }

      console.log('Co tk co email');
      const passwordMatches = await bcrypt.compare(password, user.password);
      if (!passwordMatches) {
        throw new UnauthorizedException('M·∫≠t kh·∫©u kh√¥ng ch√≠nh x√°c');
      }
      console.log('dung mat khau');

      if (user.isBanned) {
        console.log('T√†i kho·∫£n ƒë√£ b·ªã kh√≥a');
        return {
          accessToken: null,
          message: `T√†i kho·∫£n c·ªßa b·∫°n ƒë√£ b·ªã kh√≥a ƒë·∫øn ng√†y ${formatDateTime(user.bannedUntil)}`,
        };
      }

      if (fcmToken) {
        this.addFCMToken(user, fcmToken);
      }
      const tokens = await this.generateUserTokens(
        user._id,
        user.email,
        user.name,
        user.phone,
        user.role,
      );
      console.log('Da tao token');

      return {
        accessToken: tokens.accessToken,
        message: 'ƒêƒÉng nh·∫≠p th√†nh c√¥ng',
      };
    } catch (error) {
      if (error instanceof UnauthorizedException) {
        throw error;
      }
      throw new InternalServerErrorException(
        'ƒê√£ x·∫£y ra l·ªói khi ƒëƒÉng nh·∫≠p: ' + error.message,
      );
    }
  }

  async addFCMToken(user, fcmToken) {
    if (!Array.isArray(user.fcmToken)) {
      console.log('Chua co truong fcm');
      user.fcmToken = []; // üëà n·∫øu ch∆∞a c√≥, t·∫°o m·∫£ng m·ªõi
    }
    if (!user.fcmToken.includes(fcmToken)) {
      user.fcmToken.push(fcmToken);
      await user.save();
      console.log('L∆∞u FCM token th√†nh c√¥ng: ' + fcmToken);
    } else {
      console.log('L∆∞u FCM token ko th√†nh c√¥ng');
    }
  }

  async generateUserTokens(userId, email, name, phone, role) {
    try {
      const secret = this.configService.get<string>('JWT_SECRET');
      console.log('>> JWT SECRET =', secret);
      const accessToken = this.jwtService.sign(
        { userId, email, name, phone, role },
        { secret, expiresIn: '7d' }, // üëà truy·ªÅn secret tr·ª±c ti·∫øp ƒë·ªÉ test
      );
      console.log('>> accessToken =', accessToken);
      return { accessToken }; // ‚úÖ tr·∫£ v·ªÅ object c√≥ accessToken
    } catch (error) {
      throw new InternalServerErrorException('Kh√¥ng th·ªÉ t·∫°o token truy c·∫≠p');
    }
  }

  // khoi tao bookmark cho user khi user moi dang ky
  private async initializeBookMark(userId: string) {
    try {
      const bookmarkRecord = new this.BookMarkModel({
        userId: userId,
        postId: [],
      });
      if (bookmarkRecord) {
        await bookmarkRecord.save();
      }
    } catch (error) {
      console.error('Error initializing bookmark:', error);
      throw new InternalServerErrorException('Failed to initialize bookmark');
    }
  }
  private async initializeFollow(userId: string) {
    try {
      const FollowRecord = new this.FollowModel({
        userId: userId,
        postId: [],
      });
      if (FollowRecord) {
        await FollowRecord.save();
      }
    } catch (error) {
      console.error('Error initializing bookmark:', error);
      throw new InternalServerErrorException('Failed to initialize bookmark');
    }
  }

  //gui otp
  async sendOtp(email: string): Promise<string> {
    const otp = Math.floor(100000 + Math.random() * 900000).toString();

    const transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: this.configService.get<string>('GMAIL_USER'), //  t·ª´ .env
        pass: this.configService.get<string>('GMAIL_APP_PASSWORD'), //  t·ª´ .env
      },
    });

    await transporter.sendMail({
      from: this.configService.get<string>('GMAIL_USER'),
      to: email,
      subject: 'X√°c nh·∫≠n m√£ OTP',
      text: `M√£ OTP c·ªßa b·∫°n l√†: ${otp}`,
    });

    await this.otpModel.create({
      email,
      otp,
      createdAt: new Date(),
    });

    return 'OTP sent';
  }

  async verifyOtpAndResetPassword(
    email: string,
    otp: string,
    newPassword: string,
  ) {
    const record = await this.otpModel.findOne({ email, otp });
    if (!record)
      throw new BadRequestException('OTP kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n');

    const hashedPassword = await bcrypt.hash(newPassword, 10);
    await this.userModel.updateOne({ email }, { password: hashedPassword });
    await this.otpModel.deleteMany({ email });

    return 'M·∫≠t kh·∫©u ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t l·∫°i';
  }

  async verifyOtpOnly(email: string, otp: string): Promise<boolean> {
    const record = await this.otpModel.findOne({ email, otp });
    return !!record;
  }
}
